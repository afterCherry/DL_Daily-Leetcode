\- [思路](#思路)

\- [代码实现](#代码实现)

\- [代码tips](#代码tips)

# 思路

展开后的单链表就一个方向，它依次往后走的结点顺序要和二叉树的遍历顺序相同

1. 最开始：找出左子树最右边的节点以便把右子树接过来

   ```java
   // 让root的右子树作为左子树最右边结点的右子树
   pre.right=root.right;
   ```

2. 把左子树插入到右子树的地方

   ```java
   // 把左子树作为root的右子树
   root.right=root.left;
   // 设置左子树为空
   root.left=null;
   ```

3. 考虑新的【右子树的根节点】，一直【重复上边的过程】，直到新的右子树为 null

   ```java
   // 让root去right，继续进行上面这个过程。这样到最后，就是一条从原始root开始的right右结点了
   root=root.right;
   ```

# 代码实现

```java
class Solution {
    public void flatten(TreeNode root) {
        while(root!=null){
            if(root.left==null){
                root=root.right;
            }
            else{
                TreeNode pre=root.left;
                while(pre.right!=null){
                    pre=pre.right;
                }
                pre.right=root.right;
                root.right=root.left;
                root.left=null;
                root=root.right;
            }
        }
    }
}
```

# 代码tips

- 找树（可以是原始树，可以是指定的小树）的最左边结点或者最右边结点—用while循环一直走啊

  ```java
  // 找左子树最右边的结点
  
  // 找到左子树—在代码中认为找到一棵树的树根就是找到这棵树了
  // 出来循环时pre即为所求
  TreeNode pre=root.left;
  while(pre.right!=null){
    pre=pre.right;
  }
  ```

- 树的输入输出序列表示这里是层次，但是代码满足题目要求就可以了

  ```
  输入：
  [1,2,5,3,4,null,6]
  
  输出：
  [1,null,2,null,3,null,4,null,5,null,6]
  ```

  