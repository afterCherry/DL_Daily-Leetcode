

\- [思路](#思路)

  \- [我的思路](#我的思路)

  \- [绝了的思路—左边单调递增+右边单调递减，灵活应用数据结构](#绝了的思路左边单调递增右边单调递减灵活应用数据结构)

  \- [双指针](#双指针)

​    \- [思路的本质](#思路的本质)

\- [代码tips](#代码tips)



# 思路

## 我的思路

- S=dxh，让d,h的积尽可能大
  - 让面积最大，d在所有的d中不一定是最大的，h在所有的h中不一定是最大的，但是dxh一定是在所有的dxh中最大的

## 绝了的思路—左边单调递增+右边单调递减，灵活应用数据结构

- 求最大矩形面积
  - 往右选更高的？
    - 用单调递减栈让比当前竖线短的都出栈—不是暴力着对右边遍历所有了，只要有用的信息
  - 找到最大矩形面积？
    - 对右边整体遍历，固定一个元素时，对左边全部遍历，就这样更新着矩形的面积，最后结果即为所求
  - 左边怎么不暴力呢？
    - 左边是单调递增队列—两个竖线，右边的矮即高度降低就不考虑了（在右边表示构成的矩形宽度小，矮表示高度小，则对求最大矩形面积没有贡献，就不考虑了，所以得是单调递增的）
  - 思路是上面这么想的，并不一定是和代码顺序对应起来的（人类逻辑真不好学～

```java
import java.util.Deque;

class Solution {
    public int maxArea(int[] height) {
        Deque<Integer> leftDeque=new LinkedList<Integer>();
        Stack<Integer> rightStack=new Stack<Integer>();
        leftDeque.addLast(0);
        for(int i=1;i<height.length;i++){
            if(height[i]>height[leftDeque.peekLast()]);
                leftDeque.addLast(i);
            while(!rightStack.isEmpty()&&height[i]>height[rightStack.peek()]){
                rightStack.pop();
            }
            rightStack.push(i);
        }
        int res=0;
        while(!rightStack.isEmpty()){
            int right=rightStack.peek();
            rightStack.pop();
            for(int i=0;i<leftDeque.size();i++){
                int left=i;
                if(left>=right)
                    break;
                int h=Math.min(height[left],height[right]);
                int d=right-left;
                int area=h*d;
                res=Math.max(res,area);
            }
        }
        return res;
    }
}
```

## 双指针

双指针i,j从两边向中间走，则矩形的宽都是-1的，那就看往里面走长竖线还是短竖线

- 走长竖线，长竖线的替代者比长竖线矮，则矩形的高min(h[i],h[j])不变（矩形的宽度已经变小了）或者更小；替代者比长竖线长或者相等，则矩形的高min(h[i],h[j])不变
  - 矩形面积变小
- 走短竖线，短竖线的替代者比短竖线矮，则矩形的高min(h[i],h[j])变小；短竖线的替代者比短竖线高，则矩形的高min(h[i],h[j])变大；短竖线的替代者和短竖线相等，则矩形的高min(h[i],h[j])不变（矩形的宽度已经变小了）
  - 矩形面积有可能变大的

### 思路的本质

求矩形面积实质上是对所有的(dxh)的组合遍历，d变大变小不变，h变大变小不变，都是在过程中进行的，都是往dxh变大的趋势上走的，再加上走一步更新一步，最后得到的即为所求

```java
class Solution {
    public int maxArea(int[] height) {
        int res=0,left=0,right=height.length-1;
        while(left<right){
            res=height[left]<height[right]?Math.max(res,(right-left)*height[left++]):Math.max(res,(right-left)*height[right--]);
        } 
        return res;    
    }
}
```

# 代码tips

- 线性单调递增、单调递减

  - 数组—更灵活
  - 队列
    - 用LinkedList实现的双向队列可以遍历
  - 栈—只能对单头调用 API 操作，遍历没有数组O(1)灵活

- 在stack中查找元素的位置

  ```java
  // 从栈底往栈顶方向
  stack.search(obj)
  ```

- ArrayList API

  ```java
  // 定义一个ArrayList
  ArrayList<Integer> list=new ArrayList<Integer>();
  
  // 转换为数组
  int[] arr=list.toArray(new int[list.size()])
  ```

  增删查

  ```java
  // 增
  list.add(ele)
    
  // 删
  list.remove(ele)
    
  // 查
  list.get(index)
  // 是否包含一个元素
  list.contains(ele)
    
  // 判断是否为空
  list.isEmpty() 
  ```

  遍历

  ```java
  // 用索引
  for(int i=0;i<list.size();i++){
    // ...
  }
  
  // 最简单的代码
  // list的元素类型是Integer,ele就是每个元素
  for(Integer ele:list){
    value=ele;
  }
  ```

- Queue API

  ```java
  // 定义
  Queue<Integer> queue=new LinekedList<Integer>();
  ```

  增删查—就是常说的队列数据结构了，在最后添加元素，在头部删除元素

  | Queue API                   | Deque API           |
  | --------------------------- | ------------------- |
  | queue.add(ele)              | deque.addLast()     |
  | queue.offer(ele)            | deque.offerLast()   |
  |                             |                     |
  | queue.remove()              | deque.removeFirst() |
  | queue.poll()                | deque.pollFirst()   |
  |                             |                     |
  | 查只对应到deque的第一个元素 |                     |
  | queue.get()                 | deque.getFirst()    |
  | queue.peek()                | deque.peekFirst()   |

  ```java
   // 判断是否为空，和stack一样
  queue.isEmpty()
  ```

- Deque API — Double ended queue 双端队列，可以在头部和尾部操作

  优点—大小可以不固定

  

  1.当成队列用—增删查

  ```java
  // 定义
  import java.util.Deque
  Deque<Integer> deque=new LinkedList<Integer>();
  ```

  - 抛出异常的对应起来，有返回值的对应起来
  - 第一个元素指明First()，最后一个元素指明Last()

  |      | 第一个元素            |                              | 最后一个元素       |                   |
  | ---- | --------------------- | ---------------------------- | ------------------ | ----------------- |
  |      | 抛出异常—队列满或者空 | 有返回值—满或者空时返回false | 抛出异常           | 有返回值          |
  | 增   | deque.addFirst()      | deque.offerFirst()           | deque.addLast()    | deque.offerLast() |
  | 删   | deque.removeFirst()   | deque.pollFirst()            | deque.removeLast() | deque.pollLast()  |
  | 查   | deque.getFirst()      | deque.peekFirst()            | deque.getLast()    | deque.peekLast()  |

  2.当成堆栈用—增删查—都是在头部进行的

  ```java
  import java.util.Deque
  Deque<Integer> stack.new LinkedList<Integer>();
  ```

  进栈、出栈对应的是抛出异常

  | Stack API    | Deque API           |
  | ------------ | ------------------- |
  | stack.push() | deque.addFirst()    |
  | stack.pop()  | deque.removeFirst() |
  | stack.peek() | deque.peekFirst()   |

  ———————————————————————————————————————————

  遍历

  ```java
  for(int i=0;i<leftDeque.size();i++){
    // ...
  }
  ```

- 对于一个判断只有两个答案选择时，用三目运算符

  ```java
  res=height[i]<height[j]?Math.max(res,(j-i)*height[i++]:Math.max(res,(j-i)*height[j--]));
  ```

- java中可以自增，可以自减

  ```java
  h++
  ++h
    
  j--
  --j
  ```

  