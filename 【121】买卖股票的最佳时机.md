\- [思路](#思路)

  \- [暴力思想](#暴力思想)

​    \- [代码实现—超时了](#代码实现超时了)

  \- [DP](#dp)

​    \- [代码实现](#代码实现)

  \- [代码tips](#代码tips)

# 思路

## 暴力思想

- 受限制
  - 买入价格<卖出价格
  - 买入的时间在前

```java
//外层循环对【除了最后一个元素】的所有元素遍历，内层循环对【从当前到最后一个元素】的所有元素遍历
```

### 代码实现—超时了

```java
public class Solution {
    public int maxProfit(int prices[]) {
        int len=prices.length;
        if(len==1)
            return 0;
        int res=0;
        for(int i=0;i<len-1;i++){
            for(int j=i+1;j<len;j++)
                res=Math.max(res,prices[j]-prices[i]);
        }
        return res;
    }
}
```

## DP

- 问法：就要最优解，不要你具体怎么来的

- 状态—当天i是不是手上有股票j,不管有没有股票都可以知道手上的钱有多少

  ```java
  //2个下标，1个值—就这么简单的定义，管3个变量，绝了～
  dp[i][j]  
  ```

  ```java
  //当天i包含[0,i]的所有信息，所以最后输出dp[len-1][0] 0表示已经卖出，满足题目的进行完交易了
  ```

- 状态转移方程

  ```java
  //[0,i]天内今天手上没有股票
  dp[i][0]
    
  //1.昨天手上没有股票，所以今天什么也没做 dp[i-1][0]
  //2.昨天手上有股票，所以今天把股票卖了，所以手里的钱得多 dp[i-1][1]+prices[i]
  ```

  ```java
  //[0,i]天内今天手上有股票
  dp[i][1]
    
  //1.昨天手上有股票，所以今天什么也没有做 dp[i-1][1]
  //2.昨天手上没有股票，所以今天买入了股票，所以今天手上的钱少了，因为只能交易一次，所以昨天手上的钱是0，那么今天手上的钱就是-prices[i] 
  ```

### 代码实现

```java
public class Solution {
    public int maxProfit(int prices[]) {
        int len=prices.length;
        if(len==1)
            return 0;
        // 定义状态数组
        int[][]dp=new int[len][2];
        // 初始化
        dp[0][0]=0;//第一天手上没有股票，手里的现金就是0
        dp[0][1]=-prices[0];//第一天手上有股票，说明买入了股票，手里的钱就是第一天买入价的相反数（还能是负数，绝了
        // 状态转移方程
        for(int i=1;i<len;i++){
            // 今天手上没有股票
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
            // 今天手上有股票
            dp[i][1]=Math.max(dp[i-1][1],-prices[i]);
        }
        return dp[len-1][0];
    }
}

//时间复杂度：O(N)
//空间复杂度：O(N)
```

```java
//优化空间—还是二维
//把第一维压缩为2个大小—今天只由昨天决定，所以第一维能表示两天即可了，相当于二进制的0和1，但是不能绝对地让谁当0，让谁当1，真的就得这样奇偶偶奇着交替着来

public class Solution {
    public int maxProfit(int prices[]) {
        int len=prices.length;
        if(len==1)
            return 0;
        // 定义状态数组
        int[][]dp=new int[2][2];
        // 初始化
        dp[0][0]=0;//第一天手上没有股票，手里的现金就是0
        dp[0][1]=-prices[0];//第一天手上有股票，说明买入了股票，手里的钱就是第一天买入价的相反数（还能是负数，绝了
        // 状态转移方程
        for(int i=1;i<len;i++){
            // 今天手上没有股票
            dp[i%2][0]=Math.max(dp[(i-1)%2][0],dp[(i-1)%2][1]+prices[i]);
            // 今天手上有股票
            dp[i%2][1]=Math.max(dp[(i-1)%2][1],-prices[i]);
        }
        return dp[(len-1)%2][0];
    }
}

//时间复杂度：O(N)
//空间复杂度：O(1)
```

```java
//优化空间—只有一维
//二维时下标为i的行只参考下标为i-1的行，把第一维直接去掉—从降维的角度好理解，直接一看代码是怎么写的品一品

public class Solution {
    public int maxProfit(int prices[]) {
        int len=prices.length;
        if(len==1)
            return 0;
        int[]dp=new int[2];
        // 初始化—一维数组就俩状态
        dp[0]=0;
        dp[1]=-prices[0];
        // 状态转移方程
        for(int i=1;i<len;i++){
            // 今天手上没有股票
            dp[0]=Math.max(dp[0],dp[1]+prices[i]);
            // 今天手上有股票
            dp[1]=Math.max(dp[1],-prices[i]);
        }
        return dp[0];
    }
}

//时间复杂度：O(N)
//空间复杂度：O(1)
```

## 代码tips

- 数值型数组通用—长度为0或1的特判

  ```java
  int len=prices.length;
  if(len==1)
    return 0;
  ```

- Math.max(a,b) Math.min(a,b)

  ```java
  //经常就是res在那里自己更新
  res=Math.max(res,prices[j]-prices[i]);
  ```

- 定义二维数组

  ```java
  int[][]dp=new int[len][2];
  ```

- 判断奇偶性

  ```java
  //1.对2取余
  %2
    
  //2.和1按位相与—和奇数相与，结果是1；和偶数相与，结果是0—1其实是前面都是0，最后一位是1
  //适用于普通十进制数值  
  &1
  ```

- DP的两种求解形式—顶是让求的问题；底是地基，基本的部分
  - 自顶向下的递归，直到递归到最底，再一层一层着把值返回
    - 记忆化递归
      - 有重复求解的部分，就用缓存来记录每个子问题的结果
    - 知道f(8),需要f(7),f(6)...需要f(2),f(1)
  - 自底向上的递推
    - 知道f(1) = 1，f(2) = 2，就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)
- 暴力思想就是重复计算，没把计算机的优势显现出来
- 题目有限制用的条件就多了，是个好事，虽然乍一看不是好事