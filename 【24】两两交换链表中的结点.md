\- [代码实现](#代码实现)

\- [思路](#思路)

  \- [我的思路](#我的思路)

  \- [递归—这也能递归？！！！](#递归这也能递归)

\- [代码tips](#代码tips)



# 代码实现

递归

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null||head.next==null)
            return head;//这里head可能为空也有可能不为空
        ListNode next=head.next;
        head.next=swapPairs(next.next);
        next.next=head;
        return next;
    }
}
```

非递归

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy=new ListNode(0,head);
        ListNode temp=dummy;
        while(temp.next!=null&&temp.next.next!=null){
            ListNode pre=temp.next,cur=pre.next;
            temp.next=cur;
            pre.next=cur.next;
            cur.next=pre;
            // temp得去当前的pre（已经换完了），接着再执行pre=temp.next,cur=pre.next进行下一个【两个结点单元】
            temp=pre;           
        }
        return dummy.next;
    }
}
```

# 思路

## 我的思路

就是换指针关系

```java
// 两个结点中第一个结点是pre,第二个结点是cur
while(pre!=null&&cur!=null){
  pre.next=cur.next;
  cur.next=pre;
  pre=pre.next;
  cur=pre.next; 
}

```

以上这样做是过程中的通用处理，**要注意到**最开始得让dummy结点（虽然不是真正的链表的组成部分）就参与进来，再加上这样的交换逻辑所以其实要做到**用三个结点去交换两个相邻结点**，最后才得到顺理成章的链表

```java
ListNode temp=dummy;
while(temp.next!=null&&temp.next.next!=null){
  ListNode pre=temp.next,cur=pre.next;
  temp.next=cur;
  pre.next=cur.next;
  cur.next=pre;
  // temp得去当前的pre（已经换完了），接着再执行pre=temp.next,cur=pre.next进行下一个【两个结点单元】
  temp=pre;           
}
```

## 递归—这也能递归？！！！

- 本题中递归的精髓

  - 小单元调换两个相邻结点，返回小单元的结果链表—返回一个链表～返回这个链表的头指针

    ```java
    // next指针一操作，原来的指向结点就找不到了，所以要先保存下来
    ListNode next=head.next;
    head.next=swapPairs(next.next);//swapPairs(next.next)已经完成任务，整体当成一个结点，这里直接接上就可以了
    next.next=head;
    return next;
    ```

  - 在pre或者cur为空时结束递归—结束递归就看成最简单的单元就好了

    - 两个都为空，则对应前面【两个都不为空】，执行对应的操作就好了
    - pre为空，cur不为空—这种情况不存在的
    - pre不为空，cur为空—返回pre，比如链表只有一个结点[7]

    ```java
    public ListNode swapPairs(ListNode head){
      if(head==null||head.next==null)
        return head;
    }
    ```

# 代码tips

- 递归的精髓在于关注小单元，再去扩展开来

  - 小单元干了什么，返回什么
    - 返回的结果直接就调用函数来接
  - 什么条件结束递归—看成原始链表满足这个条件时要干嘛就行

- 哑结点dummy yyds，常用来提供遍历起点

  ```java
  ListNode dummy=new ListNode(0,head);
  ListNode temp=dummy;
  ```

- 第2个定义的变量和刚刚定义的变量共用一个定义类型，不用再新开一行

  ```java
  ListNode pre=temp.next,cur=pre.next;
  ```

  