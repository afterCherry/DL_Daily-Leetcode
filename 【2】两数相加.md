\- [代码实现](#代码实现)

\- [思路](#思路)

  \- [自己想的](#自己想的)

  \- [需要优化](#需要优化)

  \- [链表问题的技巧](#链表问题的技巧)



# 代码实现

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode pre=new ListNode(0);
        ListNode cur=pre,p1=l1,p2=l2;
        int carry=0;
        while(p1!=null||p2!=null){
            int a=p1==null?0:p1.val;
            int b=p2==null?0:p2.val;
            int sum=a+b+carry;
            carry=sum/10;
            cur.next=new ListNode(sum%10);
            cur=cur.next;
            if(p1!=null)           
                p1=p1.next;
            if(p2!=null)
                p2=p2.next;
        }
        if(carry==1)
            cur.next=new ListNode(1);
        return pre.next;
    }
}
```

# 思路

## 自己想的

长度不一样时，对短的链表往后补0结点

```java
// 并不是真地补上实实在在的0结点，是对遍历指针为null时，则加法的内容是0
int x=0:l1.val;// 写三目运算符时的代码思路
int x=l1==null?0:l1.val;
```

这样就可以在【只要有一个链表不为null时往下进行了】

## 需要优化

- 两个链表全都遍历完之后，如果有进位，则在结果链表加个进位结点
  - 这个进位只可能是1
    - 最极端的例子 999+999=1998
- 两个链表和对应数字虽然是逆序的，但是结果链表完全可以和对应数字用尾插法在形式上匹配的
- 进位变量名字用carry

## 链表问题的技巧

- 返回结果是头结点时，给这个目的链表造pre指针，它的下一个结点是真正的头结点head

  - 原因
    - 有个指针最起码能调用了
    - pre就在这儿像个定海神针就不动了，心安；其他指针该怎么动就怎么动就好

  ```java
  ListNode pre=new ListNode(0);
  ```

- 代码简洁明了真地赏心悦目、思路清晰哇

- 在这样的循环条件往后走的情况下，是要先判断是否满足循环条件的啊

  ```java
  // 条件为||时如此
  // p1,p2往后走时是独立的两个if—意思是当前是null时，就不往下走了
  
  while(p1!=null||p2!=null){
    // 需要判断p1==null,p2==null
    if(p1!=null)           
      p1=p1.next;
    if(p2!=null)
      p2=p2.next;
  }
  ```

  ```java
  // 拓展
  // 条件为&&时也是如此，
  
  while(p1!=null&&p2!=null){
    // 就不需要判断p1==null,p2==null了
    if(p1!=null)           
      p1=p1.next;
    if(p2!=null)
      p2=p2.next;
  }
  ```

  