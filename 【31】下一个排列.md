\- [代码实现](#代码实现)

\- [思路](#思路)

  \- [我的思路](#我的思路)

  \- [数字的升升降降](#数字的升升降降)

\- [代码tips](#代码tips)

# 代码实现

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int len=nums.length;
        for(int i=len-1;i>0;i--){
            if(nums[i]>nums[i-1]){
                Arrays.sort(nums,i,len);
                for(int j=i;j<len;j++){
                    if(nums[j]>nums[i-1]){
                        swap(nums,i-1,j);
                        return;
                    }
                }
            }
        }
        Arrays.sort(nums);
        return;
    }

    public void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
}
```

# 思路

## 我的思路

就是组合数学中的【下一个排列】

## 数字的升升降降

- 得到下一个更大的数

  - 把后面位上的【尽可能小（通过有序子数组来实现）的大数】和前面位上的小数交换，再把换完之后的【大数】后面的所有数位按照升序排列

  ![e56a66ed318d1761cd8c8f9d1521f82a30c71ecc84f551912b90d8fe254c8f3d-image](https://pic.leetcode-cn.com/e56a66ed318d1761cd8c8f9d1521f82a30c71ecc84f551912b90d8fe254c8f3d-image.png)

  ```java
  // 伪代码
  从后往前找第一对相邻升序的(i-1,i)满足A[i-1]<A[i] //[i,end)必然是降序—数学上有证明。找不到则说明[begin,end)是降序排列，直接调用sort()进行全员升序
  在[i,end)中找第一个满足A[i-1]<A[k]的k
  交换A[i-1],A[k] //此时[i,end)必是降序，逆置[i,end)——调用sort()进行升序
  ```

  ```java
  // 思路更清晰的伪代码
  从后往前找第一对相邻升序的(i-1,i)满足A[i]<A[j] ，直接对[i,end)逆置——调用sort()进行升序 //这样就是从前往后找了，才觉得思路清晰
  在[i,end)中找第一个满足A[i-1]<A[k]的k
  交换A[i-1],A[k]                                  
  ```

# 代码tips

- 对区间[i,j)进行排序

  ```java
  Arrays.sort(nums,i,j);
  ```

- 对于返回类型是void类型的函数，也可以在代码里

  ```java
  return;
  ```

- nums[i]和nums[i-1]比较，就要控制i是>0的

  ```java
  for(int i=len-1;i>0;i--){
    if(nums[i]>nums[i-1]){
      // ...
    }
  }
  ```

  