

\- [代码实现](#代码实现)

\- [思路](#思路)

  \- [我的思路](#我的思路)

  \- [在数组中查找一个数值，常用二分搜索！](#在数组中查找一个数值常用二分搜索)

\- [代码tips](#代码tips)



# 代码实现

关注哪个部分是有序数组

- 部分有序的子数组摘出来就是有序数组，就能用二分搜索

- 对于不是有序的子数组也能用二分搜索，绝了

  [3,4,5,6,7,1,2]  target=1，中间有一步用的子数组是[7,1,2]

```java
class Solution {
    public int search(int[] nums, int target) {
        int len=nums.length;
        if(len==0)
            return -1;
        if(len==1)
            return nums[0]==target?0:-1;
        int low=0,high=len-1;
        while(low<=high){
            int mid=low+(high-low)/2;
            if(nums[mid]==target)
                return mid;
            // 左边有序就去左边看看，可能能找到，可能找不到，那就去右边
            if(nums[0]<=nums[mid]){
                if(nums[0]<=target&&target<=nums[mid])
                    high=mid-1;
                else
                    low=mid+1;
            }
            else{
                if(nums[mid]<=target&&target<=nums[len-1])
                    low=mid+1;
                else
                    high=mid-1;
            }
        }
        return -1;
    }
}
```

关注target在哪个部分

- 赋值成Integer.MAX_VALUE和Integer.MIN_VALUE，进行下去数组效果特别好

```java
class Solution {
    public int search(int[] nums, int target) {
        int len=nums.length;
        if(len==0)
            return -1;
        if(len==1)
            return nums[0]==target?0:-1;
        int low=0,high=len-1;
        while(low<=high){
            int mid=low+(high-low)/2;
            if(nums[mid]==target)
                return mid;
            // target在左子区间，目标是把右子区间搞成inf—这里的左右不是以mid作为界限来分开的，是两段分别有序的子数组
            if(nums[0]<=target){
                if(nums[mid]<nums[0])
                    nums[mid]=Integer.MAX_VALUE;
            }
            // target在右子区间，目标是把左子区间搞成-inf
            else{
                if(nums[mid]>=nums[0])
                    nums[mid]=Integer.MIN_VALUE;
            }
            if(nums[mid]<target)
                low=mid+1;
            else
                high=mid-1;
        }
        return -1;
    }
}
```

# 思路

## 我的思路

倒没有旋转的意思，就是前后两个数组换个位置

- 把数值型数组按照【31 下一个排列】中用折线图表示数值元素是分析数值型数组的利器

## 在数组中查找一个数值，常用二分搜索！

- 根据nums[0]和target的关系，确定target在哪段升序子数组里，在目标子数组里用二分搜索来查找

  - nums[0]>target，则target在右子区间；nums[0]<=target，则target在左子区间

  - 两个思路

    - 子数组原来是什么样现在就是什么样

    - 把子数组变成和原始数组等长大小的数组，这样来找target就还是在有序数组里找target了

      - 原始数组[4,5,6,7,1,2,3],target=5，则target在左子数组中，则在[4,5,6,7,inf,inf,inf]里找就行了

        ```java
        if(target>=nums[0]){
          if(nums[mid]<nums[0])
            nums[mid]=Integer.MAX_VALUE;
        }
        ```

      - 原始数组[4,5,6,7,1,2,3],target=2，则target在右子数组中，则在[-inf,-inf,-inf,-inf,1,2,3]里找就行了

        ```java
        else{
          if(nums[mid]>=nums[0])
            nums[mid]=Integer.MIN_VALUE;
        }
        ```

      改完之后的nums[mid]还是继续影响区间大小的，所以后面得接

      ```java
      if(nums[mid]<target)
        low=mid+1;
      else
        high=mid-1;
      ```

# 代码tips

- 数组整体不是全局有序，而是局部有序的，也可以用二分搜索

  - 对于旋转数组，随便一个数的两边，至少一边是有序的，另外一边可能有序，可能部分有序（再分还是这样的情况，始终都是有有序的一边的，那么到最后就能把target找出来）

    

    [4,5,6,7,1,2,3]

    5左边是[4]有序；右边是[6,7,1,2,3]无序，[1,2,3]部分有序

    6左边是[4,5]有序；右边是[7,1,2,3]无序，[1,2,3]部分有序

    

    7左边是[4,5,6]有序；右边是[1,2,3]有序

    1左边是[4,5,6,7]有序；右边是[2,3]有序

    

    2左边是[4,5,6,7,1]无序，[4，5，6，7]部分有序；右边是[3]有序

    ```java
    // 左半边有序 nums[0]<=nums[mid]
    // 右半边有序 nums[mid]<=nums[len-1]
    ```

    ```java
    // 左边有序就去左边看看，可能能找到，可能找不到
    if(nums[0]<=nums[mid]){
      // 这里不能是nums[mid]，过不了样例[1,3] target=2
      if(nums[0]<=target&&target<=nums[mid])
        high=mid-1;
      else
        low=mid+1;
    }
    ```

- 二分搜索

  ```java
  // 左闭右闭
  int low=0,high=nums.length-1;
  while(low<=high){
    int mid=low+(high-low)/2;
    if(nums[mid]==target)
      return mid;
    else if(nums[mid]<target)
      low=mid+1;
    else
      high=mid-1;
  }
  ```

- 找的是目标值，那么遇到目标值返回就行，做别的事情没用；找不到就 return -1

  ```java
  // 题行一判
  if(len==0)
    return -1;
  if(len==1)
    return nums[0]==target?0:-1;
  ```

- 最小值 -inf ，最大值 inf 的代码表示

  ```java
  Integer.MAX_VALUE
  Integer.MIN_VALUE
  ```

- 科学的思路就是越想越科学，越无懈可击～

- if...else if 适合用在排除选项的时候，两个只执行一个，直接就是顺畅起来的代码；if.. if 是两个都执行，但是中间部分是可以加东西有操作的

- 没有通用代码模版的原因：在一道具体情景的题目中，对于一个条件就是受限了，只有一个选择，就不是通用模版的【有很多选择】了

