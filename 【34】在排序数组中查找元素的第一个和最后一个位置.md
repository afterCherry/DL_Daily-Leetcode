\- [代码实现](#代码实现)

\- [思路](#思路)

  \- [我的思路](#我的思路)

  \- [在数值型数组中找目标数值，就是二分搜索！](#在数值型数组中找目标数值就是二分搜索)

\- [代码tips](#代码tips)



# 代码实现

转换问题

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int len=nums.length;
        int left=find(nums,target-1);
        int right=find(nums,target)-1;
        if(left<=right&&right<len&&nums[left]==target&&nums[right]==target)
            return new int[]{left,right};
        return new int[]{-1,-1};
    }

    public int find(int[] nums,int target){
        int len=nums.length;
        int low=0,high=len-1,res=len;
        while(low<=high){
            int mid=low+(high-low)/2;
            if(nums[mid]>target){
                high=mid-1;
                res=mid;
            }
            else
                low=mid+1;
        }
        return res;
    }
}
```

# 思路

## 我的思路

线性找很好找，遍历就完了。优化思路来个二分搜索，更高效的想不出来了

## 在数值型数组中找目标数值，就是二分搜索！

- 题目中会有【有序】、【升序】这样的字眼

# 代码tips

- 指明元素的数组

  ```java
  new int[]{-1,-1}
  
  // 就是[-1,-1]
  ```

  ```java
  new int[]{a,b}
  
  // 就是[a,b]
  ```

- 转化问题—转化一小步，牛批一大步

  - 第一个位置—第一个==target的位置，就是第一个>(target-1)的位置
  - 最后一个位置—（第一个>target的位置）-1

  所以问题就转化为了找第一个>target的问题，牛批！！！

  ```java
  // 改写二分搜索，来求第一个>target的索引值
  public int find(int[] nums,int target){
    int len=nums.length;
    int low=0,high=len-1,res=len;
    while(low<=high){
      int mid=low+(high-low)/2;
      if(nums[mid]>target){
        high=mid-1;
        res=mid;
      }
      else
        low=mid+1;
    }
    return res;
  }
  ```

- 因为target并不一定在数组中，要进行判断看看是return 结果数组，还是return new[] int{-1,-1}

  ```java
  if(left<=right&&right<len&&nums[left]==target&&nums[right]==target)
    return new int[]{left,right};
  return new int[]{-1,-1};
  ```

- 二分搜索—细节是魔鬼～



