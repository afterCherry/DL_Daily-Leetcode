

\- [代码实现](#代码实现)

\- [思路](#思路)

  \- [自己想的](#自己想的)

  \- [滑动窗口—就是一个窗口去包含一串连续的字符](#滑动窗口就是一个窗口去包含一串连续的字符)



# 代码实现

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> occur=new HashSet<Character>();
        int res=0,right=-1;
        // 滑动窗口左边界就是i，一次往右走一个
        for(int i=0;i<s.length();i++){
            if(i!=0)
                occur.remove(s.charAt(i-1));
            while(right+1<s.length()&&!occur.contains(s.charAt(right+1))){
                occur.add(s.charAt(++right));
            }
            res=Math.max(res,right-i+1);
        }
        return res;
    }
}
```



# 思路

## 自己想的

没有思路

## 滑动窗口—就是一个窗口去包含一串连续的字符

- 目标子串也是一个字符串，也是有始有终的。没有思路就用暴力来走过程，很多的优秀思路都是对暴力思路的优化来的—找以每个字符开始的无重复子串，每个字符作为开始都遍历完之后，最长的目标子串也就出来了

  ```
  abcabcbb
  
  开头（ ）的（无重复子串）
  (a)bcabcbb  (abc)abcbb
  a(b)cabcbb  a(bca)bcbb
  ab(c)abcbb  ab(cab)cbb
  abc(a)bcbb  abc(abc)bb
  abca(b)cbb  abca(bc)bb
  abcab(c)bb  abcab(cb)b
  abcabc(b)b  abcabc(b)b
  abcabcb(b)  abcabcb(b)
  ```

  - 开头位置递增，结尾位置与上一个结尾位置相比最起码是不减的
    - 上一个无重复字符子串已经满足了【无重复字符】，那么不论再从哪一个字符开始都是到达相同的结束点都是【无重复】，后来再多一个字符，则可能长度增加一个，也有可能就不增加了，那么对于题目所求的就再往右边走走看看，也就是走一个字符就判断一个字符

- 用哈希集合HashSet来判断【是否有重复字符】

  ```java
  Set<Character> occur=new HashSet<Character>();
  
  // 移除一个字符
  occur.remove(ch)
  // 添加一个字符
  occur.add(ch)
  // 是否包含一个字符，返回值是true,false
  occur.contains(ch)
  ```

  - 巧妙—滑动窗口的有边界初始值是-1，表示开始时的滑动窗口整体在给的字符串左边，还没开始移动，正要开始移动

- 对于一个字符串，要指定索引的字符

  ```java
  str.charAt(pos)
  ```

- 字符串的长度

  ```java
  str.length();// 有括号
  ```

- [a...b]闭区间的长度，a b都是索引

  ```java
  b-a+1
  ```

  