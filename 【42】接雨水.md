\- [代码实现](#代码实现)

  \- [暴力](#暴力)

​    \- [优化—对于每个柱子都要往走往右找左右两边的高柱子，这是重复性工作，可以用memo来记录](#优化对于每个柱子都要往走往右找左右两边的高柱子这是重复性工作可以用memo来记录)

​      \- [memo定义](#memo定义)

  \- [备忘录memo](#备忘录memo)

  \- [双指针—不存储没有意义的值，挺妙的](#双指针不存储没有意义的值挺妙的)

​    \- [双指针的含义](#双指针的含义)

  \- [单调递减栈](#单调递减栈)

\- [代码tips](#代码tips)



# 代码实现

## 暴力

```java
class Solution {
public:
    int trap(vector<int>& height) {
        int n=height.size();
        int res=0;
        // i为0时，左边找不到最大高度；i为n-1时，右边找不到最大高度
        // 所以在[1,n-2]
        for(int i=1;i<n-1;i++){
            int l_max=-1,r_max=-1;
            // 找左边的最高柱子
            for(int j=i;j>=0;j--)
                l_max=max(l_max,height[j]);
            // 找右边的最高柱子
            for(int j=i;j<n;j++)
                r_max=max(r_max,height[j]);
            res+=min(l_max,r_max)-height[i];
        }
        return res;
    }
};
```

### 优化—对于每个柱子都要往走往右找左右两边的高柱子，这是重复性工作，可以用memo来记录

从左边来，则左边的已有柱子的最大高度就是max(左边的已有记录，当前)

从右边走，则右边的已有柱子的最大高度就是max(右边的已有记录，当前)

#### memo定义

lmax_memo[i]:nums[0…i]中的最高柱子的高度

本来表示nums[0...i-1]是更切合接雨水的想法，

只是如果左边nums[0…i]的最高柱子是nums[i]本身，-height[i]之后就是0，表示装不了雨水，逻辑上也说得通

rmax_memo[i]:nums[i…n-1]中的最高柱子的高度

## 备忘录memo

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.empty())
            return 0;
        int n=height.size();
        int res=0;
        // 全都初始化为0
        vector<int> lmax_memo(n),rmax_memo(n);
        lmax_memo[0]=height[0];
        rmax_memo[n-1]=height[n-1];
        // lmax_memo逻辑：从左往右计算lmax_memo
        for(int i=1;i<n;i++)
            // 当前状态需要以前的状态，有点DP的意思
            lmax_memo[i]=max(lmax_memo[i-1],height[i]);
        // rmax_memo逻辑：从右往左计算rmax_memo
        for(int i=n-2;i>=0;i--)
            rmax_memo[i]=max(rmax_memo[i+1],height[i]);
        // 对每个当前计算雨水高度
        for(int i=1;i<n-1;i++)
            res+=min(lmax_memo[i],rmax_memo[i])-height[i];
        return res;
    }
};


//时间复杂度：O(N)
//空间复杂度：O(N)
```

## 双指针—不存储没有意义的值，挺妙的

两个指针各自走，中间的一片区域虽然有数但是对于结果没用啊

### 双指针的含义

- l_max:height[0…left]的最大高度

  r_max:height[right…n-1]的最大高度

```java
l_max=max(l_max,height[left]);
r_max=max(r_max,height[right]);
```

- 妙的地方

  - 两个max（l_max,r_max）对于当前只有一个可以参考—从左往右处理left时，左边的柱子的最大值l_max对left下标是可以参考的，但是从右边来的r_max没有参考性，因为left与right之间还有一片中间区域对left的参考性更紧密—从右往左处理right同理

  ```java
  // 本题的双指针并不是直接地有用，l_max和r_max是直接地有用
  
  class Solution {
  public:
      int trap(vector<int>& height) {
          if(height.empty())
              return 0;
          int n=height.size();
          int l_max=height[0],r_max=height[n-1];
          int left=1,right=n-2;
          int res=0;
          while(left<=right){
              // l_max=(l_max>=height[left]?l_max:height[left]);
              // r_max=(r_max>=height[right]?r_max:height[right]);
              l_max=max(l_max,height[left]);
              r_max=max(r_max,height[right]);
              // res+=min(l_max,r_max)-height[i]
              if(l_max<r_max){
                  res+=l_max-height[left];
                  left++;
              }
              else{
                  res+=r_max-height[right];
                  right--;
              }
          }
          return res;
      }
  };
  ```

## 单调递减栈

- 挺奇妙的点

  - 一般来说是针对当前元素作为高去找区域的左右边界，但是这里单调递减栈的性质让当前元素作区域的右边界，纯粹是单调递减栈的特点决定的啊——当一道题的常规思路遇到数据结构，还是得听数据结构的特点，毕竟它有用

    ```java
    class Solution {
        public int trap(int[] height) {
                int res=0;
                Stack<Integer> stack=new Stack<>();
                for(int i=0;i<height.length;i++){
                    // 当前元素值>栈顶元素值，说明对于栈顶元素找到了右边第一个比它大的元素
                    while(!stack.isEmpty()&&height[i]>height[stack.peek()]){
                        // 找栈顶元素作为高的两边
                        int cur=stack.peek();
                        stack.pop();
                        if(stack.isEmpty())
                            break;
                        // 雨水区域的左边就是新的栈顶元素
                        int left=stack.peek();
                        // 雨水区域的右边界就是自然索引i
                        int right=i;
                        int h=Math.min(height[left],height[right])-height[cur];
                        res+=(right-left-1)*h;
                    }
                    stack.push(i);
                }
            return res;
        }
    };
    ```

# 代码tips

- 栈也就是后进先出这个特点，是有这么多的应用场景的（狗头

- 这里的数值数组，怎么考虑【位置i能达到的雨水的高度】？

  - 是左右两边已有柱子高度的小的那个

    左边的最高柱子：l_max

    右边的最高柱子：r_max

    当前位置能装的最多的雨水高度：min(l_max,r_max)

    ```java
    water[i]=min(
        # 左边的最高柱子
        max(height[0...i]),
        # 右边的最高柱子
        max(height[i...n-1])
        )-height[i]
    ```

- C++的vector数组的大小

  ```c++
  vector<int>& height
    
  int n=height.size();
  ```

  vector数组元素全都初始化为0

  ```c++
  vector<int> lmax_memo(n),rmax_memo(n);
  ```

- 出栈要加个对于【栈是否为空】的判断条件

  ```java
  while(!stack.isEmpty()&&height[i]>height[stack.peek()]){
    // 找栈顶元素作为高的两边
    int cur=stack.peek();
    stack.pop();
    if(stack.isEmpty())
      break;
  }
  ```

- 栈顶元素—用Stack定义时

  ```java
  Stack<Integer> stack=new Stack<>();
  
  stack.peek()
  ```

  