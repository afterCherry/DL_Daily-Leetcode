- [代码实现](#----)
- [算法流程](#----)
- [人间清醒](#----)
- [思路](#--)
- [理解题目](#----)



### 代码实现

```java
class Solution {
    public String convert(String s, int numRows) {
        if(numRows==1)
            return s;
        List<StringBuilder> rows=new ArrayList<StringBuilder>();
        for(int i=0;i<numRows;i++)
            rows.add(new StringBuilder());
        int flag=-1,i=0;
        for(char c:s.toCharArray()){
            rows.get(i).append(c);
            if(i==0||i==numRows-1)
                flag=-flag;
            i+=flag;
        }
        StringBuilder res=new StringBuilder();
        for(StringBuilder row:rows)
            res.append(row);
        return res.toString();
    }
}
```

- 时间复杂度：O(N)-对原字符串遍历
- 空间复杂度：O(N)-需要构建一个和原字符串等长的辅助空间

### 算法流程

- 字符继续往后遍历，行是去上一行还是下一行用flag控制

  ```java
  i+=flag
  ```

- 当行到达一个方向的终点时，就反向

  ```java
  flag=-flag
  ```

### 人间清醒

- 用flag的正负控制方向
  - 其实啥字母都可以，只是因为flag常用而已呀
- 输出的字符串还是一行字符串而已，所以字符串是按照什么样的形式存储的不关心的，关心值是0。

### 思路

对原字符串遍历，把当前字符填到它的位置中。

遍历完了，结果也就出来了

### 理解题目

对原字符串遍历，与生成字符串之间的关系：

竖着规规矩矩的一列-从第一行去最后一行；

走斜路-从最后一行去第一行

如此循环，直到结束

!image(https://github.com/afterCherry/DL_Daily_Leetcode/blob/images/6.0.png)



