\- [思路](#思路)

  \- [暴力思想](#暴力思想)

  \- [以空间换时间来降低时间复杂度—用栈](#以空间换时间来降低时间复杂度用栈)

​    \- [代码实现](#代码实现)

​    \- [可以确定矩形面积的时刻](#可以确定矩形面积的时刻)

​    \- [逻辑的思考过程决定了用栈](#逻辑的思考过程决定了用栈)

​    \- [怎么具体地用栈？](#怎么具体地用栈)

​    \- [代码tips](#代码tips)



### 思路

#### 暴力思想

![image](https://github.com/afterCherry/DL_Daily_Leetcode/blob/images/84%E6%9A%B4%E5%8A%9B.jpeg)

对所有柱子遍历，对于每个当前柱子尽可能地往两边扩散

- 两个方向
  - 尽可能地往左走：找到>=当前柱子的最左边元素的下标
  - 尽可能地往右走：找到>=当前柱子的最右边元素的下标
  - S=(两个下标相减+1)x（当前柱子的高度）
- 时间复杂度O(N^2)
  - 外层对所有柱子遍历，内层对每个珠子往两边扩散
- 空间复杂度O(1)
  - 常数级别的辅助空间

#### 以空间换时间来降低时间复杂度—用栈

![image](https://github.com/afterCherry/DL_Daily_Leetcode/blob/images/84%E4%BC%98%E5%8C%96.jpeg)

##### 代码实现

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Solution {
    public int largestRectangleArea(int[] heights) {
        int len = heights.length;
        if (len == 0) 
            return 0;
        if (len == 1) 
            return heights[0];


        int[] newHeights = new int[len + 2];
        newHeights[0] = 0;
        newHeights[len + 1] = 0;
        System.arraycopy(heights, 0, newHeights, 1, len);

        Deque<Integer> stack = new ArrayDeque<>(len);
        stack.addLast(0);
        int res = 0;
        for (int i = 1; i < len+2; i++) {
            while (newHeights[i] < newHeights[stack.peekLast()]) {
                int curHeight = newHeights[stack.pollLast()];
                int curWidth = i - stack.peekLast()-1;
                res = Math.max(res, curHeight * curWidth);
            }
            stack.addLast(i);
        }
        return res;
    }
}

//时间复杂度O(N)
//空间复杂度O(N)
```

从暴力思路中的目标结果表达式S=(两个下标相减+1)x（当前柱子的高度），可以看出只用存储下标即可

- 宽度—（两个下标相减+1）
- 高度—（当前柱子的高度）



对于当前柱子，只要相邻的右边柱子比它高，就可以往右走，这会让几个柱子的确定以其作为高的矩形面积暂时不确定，不过没关系，最极端的情况就是到最后一个柱子肯定都有各自的结果了；只要相邻的右边柱子比它低，那么就可以确定往右扩散的几个柱子的矩形面积了（并不是全部的没有确定面积的柱子都能定下来了）



##### 可以确定矩形面积的时刻

- 右边有柱子可以严格低了，左边有柱子可以严格低了，就可以确定矩形的宽度了

  - 遍历到最后一个柱子时，假设其右边是高度最起码<1的柱子（哨兵的解法，妙啊！），这样所有的柱子的面临情况就一样了，amazing~

  - 等于不可以，等于意味着可以继续往左往右扩散

- 特例

  - 对于高度为1的柱子，它能确定的矩形面积是1x（数组的宽度）=数组的宽度

##### 逻辑的思考过程决定了用栈

遍历数据时是从左往右进行的，得到矩形面积的柱子的顺序是从右往左进行的，这些面积算完就完了不再进行继续的操作

##### 怎么具体地用栈？

确定了以一个柱子作为高的矩形面积时，就从栈顶出来

开始时，栈为空；整个过程中，所有的元素都是进栈一次（表示遍历到了），出栈一次（表示确定了以这个柱子作为高的矩形的面积）；最后栈为空，表示对所有的柱子都考虑完了。

##### 代码tips

- 进行特判-数组长度为0时返回0，长度为1时则举行的宽度确定，高也知道，直接返回面积就是这唯一的柱子的高度

  ```java
  int len=heights.length;
  if(len==0)
    return 0;
  if(len==1)
    return heights[0];
  ```

- 数组复制

  ```java
  //API
  System.arraycopy(Obeject src, int srcPos, Object dest, int destPos, int length)
    
  src-原数组
  srcPos-对原数组要复制的起始下标
  dest-目标数组
  destPos-要复制过去的目标数组的起始下标
  length-要复制过去的长度
  ```

- 对栈的操作

  ```java
  //用Deque构建一个stack
  import java.util.ArrayDeque;
  import java.util.Deque;
  Deque<Integer> stack = new ArrayDeque<>(len);
  
  //只是查看栈顶对象—每次都从队尾加，则栈顶元素是队尾元素
  stack.peekLast();
  
  //返回栈顶的值—也就是队尾元素
  stack.pollLast();
  
  //往队尾添加一个元素
  stack.addLast(0);
  ```

- 对队列的操作

  ```java
  //获取并移除队列的头
  //如果队列为空，则返回null
  queue.poll();
  ```

- 疑问—为什么矩形的宽度是（右下标-左下标-1）？

  ```java
  int curWidth = i - stack.peekLast()-1;
  
  //为什么不是
  int top_index=stack.pollLast();
  int curWidth=i-top_index;
  ```

  左下标表示往左能走的最远，中间可以包含高度更高的，只要在中间就可以组成矩形，上一个栈顶就有可能和新的栈顶之间有距离（中间都是对矩形面积有贡献的柱子们），所以不能认为上一个栈顶就在现在栈顶的相邻右边一位—太细了～

![image](https://github.com/afterCherry/DL_Daily_Leetcode/blob/images/84%20%E7%96%91%E9%97%AE.jpeg)





